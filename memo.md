- **「キーとバリューを分けつつ、バリューでソートする」**
- **値自体（num）と、ソートの基準（出現頻度）を分離できる**
- **JavaのPriorityQueueのコンパレータを使うと、このようなカスタムソート条件を簡潔に表現できます。**


コンパレータ（Comparator）と最小ヒープの組み合わせが少し難しく感じた

ので、言語化しておく。

最小ヒープは、指定した順序条件に従って、ルートから小さい順にノードを格納する木構造。全てのノードは、その小ノードより、順序づけにおいて小さいか等しい。

コンパレータは、順序条件を決定する比較関数。　PriorityQueueで書いた(a, b) -> countMap.get(a) - countMap.get(b)　は、「ノードaとノードbが、関数の出力の大小で比較され、ヒープに格納されますよ」ということ

countMap.get(a)- countMap.get(b) は、マップのValueである、各数値の出現回数で引き算している。出現回数が多いものほど、他のものと比較して正になりやすいため、最小ヒープにおいては末尾におかれる。出現回数が低いものは他のものと比較して負になるので、先頭に置かれる。ゆえに、minHeap.poll();で外に出され、「常に上位ｋ個を保持する」最小ヒープが、満たしたい条件を満たす。

//マップのkeyだけを取り出す。keyの一つ一つの要素（一意）がnum。minHeapに格納するのは、keyを格納する。
for (int num: countMap.keySet()) {
  minHeap.offer(num);
  if (minHeap.size() > k) {
    minHeap.poll();
  }
}


